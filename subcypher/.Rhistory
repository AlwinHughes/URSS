getFrequenciesFromBook(book, fullalph)
source("makeSubCyper.R")
getFrequenciesFromBook(book, fullalph)
source("makeSubCyper.R")
source("makeSubCyper.R")
getFrequenciesFromBook(book, fullalph)
source("makeSubCyper.R")
getFrequenciesFromBook(book, fullalph)
source("makeSubCyper.R")
getFrequenciesFromBook(book, fullalph)
source("makeSubCyper.R")
getFrequenciesFromBook(book, fullalph)
source("makeSubCyper.R")
getFrequenciesFromBook(book, fullalph)
source("makeSubCyper.R")
getFrequenciesFromBook(book, fullalph)
source("makeSubCyper.R")
source("makeSubCyper.R")
getFrequenciesFromBook(book, fullalph)
source("makeSubCyper.R")
getFrequenciesFromBook(book, fullalph)
book = readLines("../LoveOfTheWild.txt")
book = readLines("../LoveOfTheWild")
book = readLines("../books/LoveOfTheWild")
book = readLines("../books/LoveOfTheWild.txt")
book
book = readLines("../books/LoveOfTheWild.txt")
getFrequenciesFromBook(book, fullalph)
book
getFrequenciesFromBook(book, fullalph2)
source("makeSubCyper.R")
getFrequenciesFromBook(book, fullalph2)
source("makeSubCyper.R")
getFrequenciesFromBook(book, fullalph2)
fullalph2
book = readLines("../books/LoveOfTheWild.txt")
getFrequenciesFromBook(book, fullalph2)
source("makeSubCyper.R")
getFrequenciesFromBook(book, fullalph2)
ls
ls()
a1
rm a1
rm(applycypher, composeCyper, encrypt, getFrequencies, loweralph, upperalph, createSubCyph, fullalph, getFrequencies, m1, c1, cyphertext, fullalph, inverse)
source("makeSubCyper.R")
getFrequenciesFromBook(book, fullalph2)
ls()
getFrequenciesFromBook(book, fullalph2)
source("makeSubCyper.R")
getFrequenciesFromBook(book, fullalph2)
ls()
n
source("makeSubCyper.R")
getFrequenciesFromBook(book, fullalph2)
n
ls(
)
rm(applycypher, composeCyper, encrypt, getFrequencies, m2, createSubCyph, fullalph, loweralph, c1, cyphertext, fullalph2, inverseSubCyperm1, upperalph)
rm(applycypher, composeCyper, encrypt, getFrequencies, m2, createSubCyph, fullalph, loweralph, c1, cyphertext, fullalph2, inverseSubCyperm, upperalph)
ls()
rm(m1, inverseSubCyper)
ls()
q()
ls()
F = getFrequenciesFromBook(book, fullalph2)
F = getFrequenciesFromBook(book, lotwfullalph)
F
plot(F[53])
F[53]
F[,53]
F[53,]
plot(F[53,])
plot(F[5,])
F[5,]
lotwfullalph[54]
q()
install.packages("liqueueR")
exit
q()
install.packages("liqueueR")
install.packages("tcltk")
install.packages("asdlkfjak;sdfja;ldkfajf;akdf")
q()
install.packages("tcltk")
install.packages("liqueueR")
install.packages("github.com/DataWookie/liqueueR
NeedsCompilation:no
Materials:README
CRAN checks:liqueueR results
"
)
install.packages("github.com/DataWookie/liqueueR", type="sourc")
q()
ls()
book
source("breakSubCypher.R")
source("makeSubCyper.R")
source("makeSubCyper.R")
source("breakSubCypher.R")
wholebook = paste(book, collapse= '')
wholebook
bookcvec = strsplit(wholebook, '')
bookcvec
numbookvec = convertMessageToNumeric(bookcvec, lotwfullalph)
source("breakSubCypher.R")
numbookvec = convertMessageToNumeric(bookcvec, lotwfullalph)
numbookvec = convertMessageToNumeric(bookcvec, lotwfullalph)
1 = 1
1 == 1
source("makeSubCyper.R")le
numbookvec = convertMessageToNumeric(bookcvec, lotwfullalph)
length(message)
length(bookcv)
bookcvec[1]
clear
numbookvec = convertMessageToNumeric(wholebook, lotwfullalph)
numbookvec
numbookvec[1]
numbookvec[2]
numbookvec[3]
numbookvec[4]
ls()
w
()
q()
beat
beta
beta
beta(a,b)
beta(2,3)
beta(2,3,5)
beta(23131,3)
P
ls()
R
F
q()
a = strsplit(wholebook, "")
length(a)
a[[1]]
a[[1]][1]
a[[1]][2]
a[[1]][3]
a[[1]][]4
a[[1]][4]
length(a[[1]])
typeof(a[[1]])
is.vector(a[[1]])
bookcvec = bookcvec[[1]]
length(bookcvec)
F
ls()
P
booknumvec = mapply(function(x) {match(x,lotwfullalph) },bookcvec)
booknumvec
booknumvec[1:10]
bookcvec[1:10
]
bookcvec[1:20]
booknumvec[1:20]
booknumvec[1]
booknumvec[1] + 0
booknumvec[1] + 2
lotwfullalph[booknumvec[1] + 2]
lotwfullalph[booknumvec[1] ]
beta
beta = numeric(
source("breakSubCypher.R")
beta = getBeta(booknumvec, lotwfullalph)
beta
numeric(2, 0)
numeric(length = 2, 0)
numeric(2)
source("breakSubCypher.R")
beta = getBeta(booknumvec, lotwfullalph)
beta
source("breakSubCypher.R")
source("makeSubCyper.R")
plaintext = "The need to protect secrets via encryption has existed for millennia, and for just
as long the desire to intercept and decode such secrets has been its counterpart.
Traditionally, cryptanalysis has been a tedious, manual process, but with recent
advances in computing, new methods are being developed that require little human input. This dissertation will develop and assess such a method, known as
Markov chain Monte Carlo, in its ability to decode classical ciphers. A new implementation for transposition ciphers is proposed, and is found to outperform
the existing algorithm by all accounts. The final class of ciphers considered is
polyalphabetic ciphers, a mostly unexplored area for this type of algorithm. This
is then extended to decode one of the most notorious polyalphabetic ciphers ever
conceived: the Vigen`ere cipher. In each case, the algorithms developed are found
to be successful in decoding the ciphertexts to a human-readable standard, all the
while requiring far less parameter tuning than other popular approaches. This
adaptability may be the key for attacking ciphers given less knowledge of the
encryption technique a priori."
plaintext
plaintext = strsplit(plaintext, '\n')[[1]]
plaintext
plaintext = paste( plaintext, collapse= '')
plaintext
plaintext.num = convertMessageToNumeric(plaintext, lotwfullalph)
plaintext.num
cypher
cypher = createSubCyph(lotwfullalph)
cypher = createSubCyph(length(lotwfullalph)__
cypher = createSubCyph(length(lotwfullalph))
cypher
zip
P
ls
ls()
F$rows
F$rows
tm = matrix(ncol = 2, nrow=2, 3)
tm
aply(tm, c(2,2), function(x) { return(x + 1)})
apply(tm, c(2,2), function(x) { return(x + 1)})
apply(tm, 2, function(x) { return(x + 1)})
apply(tm, 1, function(x) { return(x + 1)})
apply(tm, 1, function(x) { return(x + 1)})
P.log = apply(F, 2, function(x) { 
if(x ==) { return(-12) }
source("breakSubCypher.R")
source("breakSubCypher.R")
P = getP.log(booknumvec, lotwfullalph)
source("breakSubCypher.R")
source("breakSubCypher.R")
P = getP.log(booknumvec, lotwfullalph)
source("breakSubCypher.R")
P = getP.log(booknumvec, lotwfullalph)
source("breakSubCypher.R")
P = getP.log(booknumvec, lotwfullalph)
source("breakSubCypher.R")
P = getP.log(booknumvec, lotwfullalph)
P
P = getP.log(booknumvec, lotwfullalph)
P
mata = matrix(ncol = 4, nrow =4, 2)
mata
apply(mata, 2, function(x) { return(x + 1)})
mata[1]
mata[1,]
mata[1,] = c(1,2,3,4)
mata
apply(mata, 2, function(x) { return(x + 1)})
source("breakSubCypher.R")
P.log = getP.log(booknumvec, lotwfullalph)
P.log
source("breakSubCypher.R")
P.log = getP.log(booknumvec, lotwfullalph)
P.log
getP.log(booknumvec, lotwfullalph)
source("breakSubCypher.R")
getP.log(booknumvec, lotwfullalph)
source("breakSubCypher.R")
getP.log(booknumvec, lotwfullalph)
source("breakSubCypher.R")
getP.log(booknumvec, lotwfullalph)
source("breakSubCypher.R")
getP.log(booknumvec, lotwfullalph)
bookcvec
booknumvec
booknumvec[1]
booknumvec[2]
source("breakSubCypher.R")
getP.log(booknumvec, lotwfullalph)
source("breakSubCypher.R")
getP.log(booknumvec, lotwfullalph)
getP.log(booknumvec, lotwfullalph)
log(2)
log(123/1200)
source("breakSubCypher.R")
getP.log(booknumvec, lotwfullalph)
source("breakSubCypher.R")
getP.log(booknumvec, lotwfullalph)
source("breakSubCypher.R")
P.log = getP.log(booknumvec, lotwfullalph)
P.log
plaintext
ls()
plaintext.num
plaintext.num[1]
plaintext.num[2]
plaintext.num[1:10]
source("breakSubCypher.R")
plaintext
plaintext.num
beta
cypher
cyphertext.num = applycyphernum(cypher, plaintext.num)
cyphertext.num
source("breakSubCypher.R")
cyphertext.num = applycyphernum(cypher, plaintext.num)
cyphertext.num
source("makeSubCyper.R")
cyphertext.num = applycyphernum(cypher, plaintext.num)
cyphertext.num
plaintext.num
source("makeSubCyper.R")
cyphertext.num = applycyphernum(cypher, plaintext.num)
cyphertext.num
beta 
apply(c(1,2,3,4), 1, function(x) { return(x+1) })
mapply(c(1,2,3,4), 1, function(x) { return(x+1) })
apply
mapply(c(1,2,3,4), function(x) { return(x+1) })
mapply(function(x) { return(x+1) }, c(1,2,3))
source("breakSubCypher.R")
getBeta(booknumvec, lotwfullalph)
getBeta(booknumvec, lotwfullalph)
booknumvec
booknumvec[2]
lotwfullalph[booknumvec[2]]
source("breakSubCypher.R")
getBeta(booknumvec, lotwfullalph)
beta
source("breakSubCypher.R")
getBeta(booknumvec, lotwfullalph)
mapply
getBeta(booknumvec, lotwfullalph)
source("breakSubCypher.R")
getBeta(booknumvec, lotwfullalph)
beta = getBeta(booknumvec, lotwfullalph)
breakCypher(cyphertext.num, beta, lotwfullalph, M = 100)
P.log
source("breakSubCypher.R")
breakCypher(cyphertext.num, beta, P.log, lotwfullalph, M = 100)
source("breakSubCypher.R")
breakCypher(cyphertext.num, beta, P.log, lotwfullalph, M = 100)
source("breakSubCypher.R")
breakCypher(cyphertext.num, beta, P.log, lotwfullalph, M = 100)
source("breakSubCypher.R")
breakCypher(cyphertext.num, beta, P.log, lotwfullalph, M = 100)
source("breakSubCypher.R")
breakCypher(cyphertext.num, beta, P.log, lotwfullalph, M = 100)
source("../R_Packages/liqueueR/")
source("../R_Packages/liqueueR/R/queue.R")
breakCypher(cyphertext.num, beta, P.log, lotwfullalph, M = 100)
source("../R_Packages/liqueueR/R/queue.R")
breakCypher(cyphertext.num, beta, P.log, lotwfullalph, M = 100)
source("../R_Packages/liqueueR/R/queue.R")
breakCypher(cyphertext.num, beta, P.log, lotwfullalph, M = 100)
source("breakSubCypher.R")
breakCypher(cyphertext.num, beta, P.log, lotwfullalph, M = 100)
breakCypher(cyphertext.num, beta, P.log, lotwfullalph, M = 100)
source("breakSubCypher.R")
breakCypher(cyphertext.num, beta, P.log, lotwfullalph, M = 100)
source("breakSubCypher.R")
breakCypher(cyphertext.num, beta, P.log, lotwfullalph, M = 100)
source("breakSubCypher.R")
breakCypher(cyphertext.num, beta, P.log, lotwfullalph, M = 100)
source("breakSubCypher.R")
breakCypher(cyphertext.num, beta, P.log, lotwfullalph, M = 100)
let res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 1000000)
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 1000000)
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 10000)
res
beta
beta[cyphertext.num[1]]
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 1000)
res
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 1000)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 1000)
res
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 1000)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 1000)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 1000)
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 10)
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100)
res
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100)
print("bob" + 2)
print("bob" ++ 2)
print("bob" , 2)
res
runif(1)
print("bob" + "steve")
print("bob"  "steve")
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100)
P.log
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100)
res
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 20)
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 20)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 20)
res
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 1000)
res
cypher
inverseSubCyper(cypher)
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 10000)
res
res$data
res$data[[1]]
inverseSubCyper(cypher)
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100000)
res$data$[[1]]
res$data[[1]]
unencrypted = applycyphernum(res$data[[1]], cyphertext.num)
unencrypted
convertNumericToMessage(unencrypted, lotwfullalph)
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100000)
res
res[[10]]
res$data[[10]]
convertNumericToMessage(applycyphernum(res$data[[10]],cyphertext.num ), lotwfullalph)
plaintext
convertNumericToMessage(applycyphernum(inverseSubCyper(cypher),cyphertext.num ), lotwfullalph)
inverseSubCyper(cypher)
res$data[[1]]
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100000)
convertNumericToMessage(applycyphernum(res$data[[10]],cyphertext.num ), lotwfullalph)
convertNumericToMessage(applycyphernum(res$data[[1]],cyphertext.num ), lotwfullalph)
ls()
q()
convertNumericToMessage(applycyphernum(res$data[[1]],cyphertext.num ), lotwfullalph)
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100000)
res$data
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100000)
res
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100000)
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100000)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100000)
res$data
res
convertNumericToMessage(applycyphernum(res$data[[1]],cyphertext.num ), lotwfullalph)
convertNumericToMessage(applycyphernum(res$data[[10]],cyphertext.num ), lotwfullalph)
convertNumericToMessage(applycyphernum(inverseSubCyper(cypher),cyphertext.num ), lotwfullalph)
inverseSubCyper(cypher)
res$data[[1]]
res$data[[10]]
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 10000)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 10000)
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 10000)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 10000)
res$data
inverseSubCyper(cypher)
cypher
convertNumericToMessage(applycyphernum(inverseSubCyper(data[[10]]),cyphertext.num ), lotwfullalph)
convertNumericToMessage(applycyphernum(inverseSubCyper(res$data[[10]]),cyphertext.num ), lotwfullalph)
res$priorities
convertNumericToMessage(applycyphernum(inverseSubCyper(res$data[[10]]),cyphertext.num ), lotwfullalph)
res$priorities
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 10000)
convertNumericToMessage(applycyphernum(inverseSubCyper(res$data[[10]]),cyphertext.num ), lotwfullalph)
convertNumericToMessage(applycyphernum(res$data[[10]],cyphertext.num ), lotwfullalph)
pq
res
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 10000)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 10000)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100000)
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100000)
P.log
source("breakSubCypher.R")
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 100000)
res = breakCypher(cyphertext.num, beta, P.log, lotwfullalph, 10000)le
res$priorities
source("breakSubCypher.R")
length(lotwfullalph)
cipher = createSubCyph(length(lotwfullalph))
cipher
ciphertext.number = applycypher(cipher, plaintext.num)
ciphertext.number = applycyphernum(cipher, plaintext.num)
ciphertext.number
plaintext.num
plaintext.num[1:10]
ciphertext.number[1:10]
cypher[18]
cypher[46]
cipher[18]
cipher[46]
res = breakCypher(ciphertext.number, alphabet=lotwfullalph, 1000)
res
source("breakSubCypher.R")
res = breakCypher(ciphertext.number, alphabet=lotwfullalph, 1000)
res = breakCypher(ciphertext.number, alphabet=lotwfullalph, 10000)
source("breakSubCypher.R")
res = breakCypher(ciphertext.number, alphabet=lotwfullalph, 10000)
res = breakCypher(ciphertext.number, beta, P.log, lotwfullalph, 10000)
res
cipher
q()
res = breakCypher(ciphertext.number, beta, P.log, lotwfullalph, 10000)
q()
